---
title: JVM内存模型
date: 2020-10-13 16:42:00
updated: 2020-10-13 16:42:00
type:
comments:
description: JVM内存模型
keywords: JVM内存模型
top_img: https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/index.jpg
cover: http://qiniu.lancaiwu.com/1534147-20200327123738925-641573596.png
tag: JVM
categories: Java
---

# 前言

JVM常见知识点,面试要求必会题,必须学习一波

## JVM 内存模型

1. 方法区
2. Java虚拟机栈
3. 本地方法栈
4. 程序计数器
5. 堆

![jvm.png](http://qiniu.lancaiwu.com/1534147-20200327123738925-641573596.png)

### 1. 方法区
方法区是被所有线程共享的区域，用于存放已被虚拟机加载的类信息、常量、静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。这里的内存回收主要针对常量池回收及堆类型的卸载。

### 2. Java虚拟机栈
虚拟机栈是线程私有的，生命周期与线程相同。是Java方法运行过程的内存模型，Java虚拟机栈会为每一个即将执行的方法创建一个“栈帧”的区域，用来存储该方法运行时候的一些信息，包括:局部变量、操作数栈、动态链接、方法返回地址等。**栈帧**创建完成后，会将该“栈帧”入栈到Java虚拟机栈，每个方法被调用到方法被执行完，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。当内存不足时会发生OutOfMemoryError。

### 3. 本地方法栈
本地方法栈是线程私有的。本地方法栈的结构与Java虚拟栈结构一样，只不过Java虚拟栈运行Java方法的区域，而本地方法栈是运行本地方法的内存模型。运行本地方法(native)时也会创建**栈帧**并将其入栈，**栈帧**也是保存着 局部变量表、操作数栈、动态链接栈、方法返回地址等。本地方法(native)执行结束后，**栈帧**也会从本地方法栈出栈并释放内存资源，当内存不足时会发生OutOfMemoryError。

### 4. 程序计数器
程序计数器是线程私有的。内存空间较小，用来记录当前线程正在执行的那一条字节码指令地址。如果当前线程正在执行的是本地方法(native)的，那么此时程序计数器为空。程序计数器有两个作用: (1)字节码解释器通过改变程序计数器来一次读取指令,从而实现代码的流程控制,比如常见的顺序、循环、选择、异常处理等。(2)在多线程的情况下，程序计数器用来记录当前线程执行的位置，当线程切回来的时候仍然可以知道该线程上次执行到哪里了，而且程序计数器是唯一个不会出现OutOfMemoryError的内存区域。

### 5.堆
堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。当堆中无内存可以分配时候，则会抛出OutOfMemoryError异常。堆区是主要GC的区域，通常情况下堆区分为**新生代**、**老年代**
> #### 新生代
> 新生代主要用来存放新生成的对象，在新生代中保存着大量刚刚创建的对象，但是大部分都是朝生夕死,所以在新生代中会频繁的进行MinorGC,进行垃圾回收。新生代又划分为: **Eden区**(伊甸区)、**From Survivor 区**(幸存者0区)、**To Survivor 区**(幸存者1区)，默认情况下各自内存占比 8:1:1 。
>* **Eden区**：Java新创建的对象绝大部分会分配在Eden去(如果对象太大,则会直接分配到老年代)。当Eden区内存不够的时候，就会触发MinorGC(YGC,新生代采用**分代复制算法**)，对新生代进行一次垃圾回收。
>* **Survivor From 与 Survivor To 区**: 在GC开始的时候，对象只会在Eden区和 Survivor From区，Survivor To区是空的，一次MinorGC(Young GC)过后，Eden区和Survivor From区存活的对象会移动到Survivor To区，然后会清空Eden区和Survivor From区，并增加存活的对象年龄+1，当存活的对象年龄达到15时，则将该对象会被移动到老年代，MinorGC完成后，Survivor From和Survivor To区的功能进行互换，下一次MinorGC(Young GC)时，会如此反过来操作。
> #### 老年代
>老年代主要存放应用中生命周期比较长的内存对象，老年代比较稳定，不会频繁发生MajorGC,而在MaiorGC之前才会先进行一次MinorGC,使的新生代的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间。Full GC .
>在老年代中，MajorGC采用了 **标记-清除算法**：首先扫描一次所有老年代里面的对象，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时较长，因为要扫描再回收。MajorGC会产生内存碎
片，当老年代也没有内存分配给新来的对象时候，就会抛出OOM异常。
>
> ![dump.png](http://qiniu.lancaiwu.com/1534147-20200327124539659-2034680216.png)
>
> #### 永久代
>永久代是hotspot虚拟机，也就是我们使用的java虚拟机特有概念，他不属于堆内存，是方法区的一种实现，主要是永久保存的区域。
> #### 元空间
>元空间是Mataspace，在jdk1.8的时候，jvm移除了永久代的概念，元空间也是对java虚拟机的方法区的一种实现。元空间与永久代的最大区别在于，元空间不在虚拟机中，使用本地内存。
>-XX:MataspaceSize: 初始空间的大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整。如果释放了大量空间，就适当降低该值；如果释放了很少空间，那么在不超过MaxMataspaceSize时，适当提高该值。
>-XX:MaxMataspaceSize时，最大空间，默认是没有限制的。
>永久代的回收会随着full gc进行移动，消耗性能。每种类型的垃圾回收都需要特殊处理元数据，将元数据剥离出来，简化了垃圾收集，提高了效率。
> * 采用元空间而放弃永久代的原因:
> (一) 解决永久代OOM 问题，元数据和class对象存放永久代，容易出现性能问题和内存溢出问题
> (二) 类及方法的信息比较难确定其大小，因此对于永久代大小指定比较困难，太小容易永久代内存溢出，太大容易导致老年代溢出.
> (三) 永久代会为GC带来不必要的复杂度，并回收效率偏低。